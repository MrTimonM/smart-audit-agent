/**
 * Create Pull Request Action
 * 
 * Creates a GitHub PR with audit findings and suggested fixes
 */

import { Octokit } from '@octokit/rest';
import * as fs from 'fs/promises';
import * as path from 'path';
import simpleGit from 'simple-git';
import { createLogger } from '../utils/logger';
import { config } from '../utils/config';
import type { Finding } from './runStaticAnalysis';
import type { Fix } from './generateFixes';
import type { DynamicTestResult } from './runDynamicTests';

const logger = createLogger('CreatePR');

export interface CreatePRInput {
  repoPath: string;
  repoUrl: string;
  findings: Finding[];
  fixes: Fix[];
  dynamicTestResult?: DynamicTestResult;
  auditId: string;
}

export interface CreatePRResult {
  success: boolean;
  prUrl?: string;
  prNumber?: number;
  branch: string;
  error?: string;
}

/**
 * Extracts owner and repo from GitHub URL
 */
function parseGitHubUrl(url: string): { owner: string; repo: string } | null {
  const match = url.match(/github\.com[:/]([^/]+)\/([^/.]+)/);
  if (!match) return null;
  
  return {
    owner: match[1],
    repo: match[2].replace('.git', ''),
  };
}

/**
 * Generates PR body with audit report
 */
function generatePRBody(
  findings: Finding[],
  fixes: Fix[],
  dynamicTestResult?: DynamicTestResult,
  auditId?: string
): string {
  const criticalFindings = findings.filter(f => f.severity === 'critical');
  const highFindings = findings.filter(f => f.severity === 'high');
  const mediumFindings = findings.filter(f => f.severity === 'medium');
  
  let body = `# üîí Smart Contract Security Audit Report

**Audit ID:** \`${auditId}\`
**Generated by:** SmartAudit Agent (powered by ADK-TS)
**Date:** ${new Date().toISOString()}

## üìä Executive Summary

`;
  
  body += `
| Severity | Count |
|----------|-------|
| üî¥ Critical | ${criticalFindings.length} |
| üü† High | ${highFindings.length} |
| üü° Medium | ${mediumFindings.length} |
| üîµ Low | ${findings.filter(f => f.severity === 'low').length} |
| ‚ÑπÔ∏è Info | ${findings.filter(f => f.severity === 'info').length} |
| **Total** | **${findings.length}** |

`;
  
  if (fixes.length > 0) {
    body += `## ‚úÖ Automated Fixes

This PR includes **${fixes.length}** automated fixes for common security issues:

`;
    
    for (const fix of fixes) {
      body += `### ${fix.findingId} - ${fix.file}:${fix.line}

**Confidence:** ${fix.confidence.toUpperCase()}

${fix.explanation}

\`\`\`diff
- ${fix.originalCode}
+ ${fix.fixedCode}
\`\`\`

`;
    }
  }
  
  body += `## üîç Top Priority Issues

`;
  
  const topIssues = [...criticalFindings, ...highFindings].slice(0, 5);
  
  for (const finding of topIssues) {
    const severityEmoji = finding.severity === 'critical' ? 'üî¥' : 'üü†';
    body += `### ${severityEmoji} ${finding.title}

**File:** \`${finding.file}:${finding.line}\`
**Severity:** ${finding.severity.toUpperCase()}
**Confidence:** ${finding.confidence}

${finding.description}

**Recommendation:** ${finding.recommendation}

---

`;
  }
  
  if (dynamicTestResult) {
    body += `## üß™ Dynamic Testing Results

Tested on **Arbitrum Sepolia** (Chain ID: ${dynamicTestResult.chainId})

| Metric | Value |
|--------|-------|
| Contracts Deployed | ${dynamicTestResult.summary.totalDeployed} |
| Test Transactions | ${dynamicTestResult.summary.totalTransactions} |
| Successful | ${dynamicTestResult.summary.successfulTx} |
| Failed | ${dynamicTestResult.summary.failedTx} |
| Total Gas Used | ${dynamicTestResult.summary.totalGasUsed} |

`;
    
    if (dynamicTestResult.deployments.length > 0) {
      body += `### Deployed Contracts

`;
      for (const deploy of dynamicTestResult.deployments) {
        body += `- **${deploy.contractName}**: [\`${deploy.address}\`](https://sepolia.arbiscan.io/address/${deploy.address})
`;
      }
    }
  }
  
  body += `
## üìù Full Report

The complete audit report with all findings is available in \`memory/${auditId}/\`.

## ‚ö†Ô∏è Important Notes

- **Review all changes carefully** before merging
- High confidence fixes are safe to apply, but always verify
- Medium/Low confidence fixes require manual review
- This is an automated audit - manual security review is still recommended

## üîó Resources

- [Audit Logs](memory/${auditId}/)
- [Arbitrum Sepolia Explorer](https://sepolia.arbiscan.io/)
- [SmartAudit Agent Documentation](../smart-audit-agent/README-agent.md)

---

*This PR was automatically generated by SmartAudit Agent. Report issues at your repository.*
`;
  
  return body;
}

/**
 * Creates a GitHub PR with audit findings
 */
export async function createPR(input: CreatePRInput): Promise<CreatePRResult> {
  logger.info('Creating GitHub PR with audit findings...');
  
  try {
    if (!config.githubToken) {
      throw new Error('GitHub token not configured');
    }
    
    // Parse repo URL
    const repoInfo = parseGitHubUrl(input.repoUrl);
    if (!repoInfo) {
      throw new Error('Invalid GitHub URL');
    }
    
    // Initialize git and Octokit
    const git = simpleGit(input.repoPath);
    const octokit = new Octokit({ auth: config.githubToken });
    
    // Create new branch
    const branchName = `security-audit/${input.auditId}`;
    await git.checkoutLocalBranch(branchName);
    logger.info(`Created branch: ${branchName}`);
    
    // Apply fixes if any
    if (input.fixes.length > 0) {
      for (const fix of input.fixes) {
        try {
          const filePath = path.join(input.repoPath, fix.file);
          const content = await fs.readFile(filePath, 'utf-8');
          const lines = content.split('\n');
          
          // Replace the line
          lines[fix.line - 1] = fix.fixedCode;
          
          await fs.writeFile(filePath, lines.join('\n'), 'utf-8');
          logger.debug(`Applied fix to ${fix.file}:${fix.line}`);
        } catch (error) {
          logger.warn(`Failed to apply fix to ${fix.file}: ${error}`);
        }
      }
      
      // Commit changes
      await git.add('.');
      await git.commit(`chore(security): apply automated security fixes

Applied ${input.fixes.length} automated security fixes:
${input.fixes.map(f => `- ${f.findingId}: ${f.file}:${f.line}`).join('\n')}

Generated by SmartAudit Agent
Audit ID: ${input.auditId}`);
      
      logger.info('Committed automated fixes');
    }
    
    // Add audit report
    const reportDir = path.join(input.repoPath, 'memory', input.auditId);
    await fs.mkdir(reportDir, { recursive: true });
    
    const reportContent = {
      auditId: input.auditId,
      timestamp: new Date().toISOString(),
      findings: input.findings,
      fixes: input.fixes,
      dynamicTestResult: input.dynamicTestResult,
    };
    
    await fs.writeFile(
      path.join(reportDir, 'audit-report.json'),
      JSON.stringify(reportContent, null, 2),
      'utf-8'
    );
    
    await git.add('.');
    await git.commit('docs(security): add audit report');
    
    // Push branch
    logger.info('Pushing branch to remote...');
    await git.push('origin', branchName, ['--set-upstream']);
    
    // Create PR
    const prBody = generatePRBody(
      input.findings,
      input.fixes,
      input.dynamicTestResult,
      input.auditId
    );
    
    const { data: pr } = await octokit.pulls.create({
      owner: repoInfo.owner,
      repo: repoInfo.repo,
      title: `chore(audit): automated security report & suggested fixes`,
      head: branchName,
      base: 'main',
      body: prBody,
    });
    
    logger.info(`PR created: ${pr.html_url}`);
    
    return {
      success: true,
      prUrl: pr.html_url,
      prNumber: pr.number,
      branch: branchName,
    };
  } catch (error) {
    const errorMsg = error instanceof Error ? error.message : String(error);
    logger.error(`Failed to create PR: ${errorMsg}`);
    
    return {
      success: false,
      branch: '',
      error: errorMsg,
    };
  }
}
