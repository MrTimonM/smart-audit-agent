/**
 * Generate Fixes Action
 * 
 * Uses AI to generate automated fixes for security findings
 */

import { AgentBuilder } from '@iqai/adk';
import * as fs from 'fs/promises';
import * as path from 'path';
import { z } from 'zod';
import { createLogger } from '../utils/logger';
import { config } from '../utils/config';
import type { Finding } from './runStaticAnalysis';

const logger = createLogger('GenerateFixes');

export interface Fix {
  findingId: string;
  file: string;
  line: number;
  originalCode: string;
  fixedCode: string;
  explanation: string;
  confidence: 'high' | 'medium' | 'low';
}

export interface GenerateFixesResult {
  success: boolean;
  fixes: Fix[];
  patchFile?: string;
  summary: {
    total: number;
    highConfidence: number;
    mediumConfidence: number;
    lowConfidence: number;
  };
  duration: number;
  error?: string;
}

/**
 * Determines if a finding can be auto-fixed
 */
function isAutoFixable(finding: Finding): boolean {
  const autoFixableCategories = [
    'visibility',
    'naming-convention',
    'solhint',
    'style',
    'gas-optimization',
  ];
  
  const autoFixablePatterns = [
    /visibility/i,
    /public.*should.*external/i,
    /constant.*should.*immutable/i,
    /naming convention/i,
  ];
  
  return (
    autoFixableCategories.some(cat => finding.category.includes(cat)) ||
    autoFixablePatterns.some(pattern => pattern.test(finding.title))
  );
}

/**
 * Generates AI-powered fix for a finding
 */
async function generateFixForFinding(
  finding: Finding,
  repoPath: string
): Promise<Fix | null> {
  try {
    const filePath = path.join(repoPath, finding.file);
    const fileContent = await fs.readFile(filePath, 'utf-8');
    const lines = fileContent.split('\n');
    
    // Get context around the issue (5 lines before and after)
    const startLine = Math.max(0, finding.line - 6);
    const endLine = Math.min(lines.length, finding.line + 4);
    const contextCode = lines.slice(startLine, endLine).join('\n');
    const originalLine = lines[finding.line - 1] || '';
    
    // Create fix schema
    const fixSchema = z.object({
      fixedCode: z.string().describe('The fixed version of the problematic line'),
      explanation: z.string().describe('Brief explanation of the fix'),
      confidence: z.enum(['high', 'medium', 'low']).describe('Confidence level of the fix'),
    });
    
    // Use AI to generate fix
    const { runner } = await AgentBuilder.withModel(config.llmModel)
      .withOutputSchema(fixSchema)
      .build();
    
    const prompt = `You are a Solidity security expert. Fix the following security issue:

Finding: ${finding.title}
Description: ${finding.description}
Severity: ${finding.severity}
Recommendation: ${finding.recommendation}

File: ${finding.file}
Line ${finding.line}:
\`\`\`solidity
${contextCode}
\`\`\`

Provide ONLY the fixed version of line ${finding.line}, not the entire context.
Original line: ${originalLine.trim()}

Return the fixed code, explanation, and confidence level.`;
    
    const result = await runner.ask(prompt);
    
    return {
      findingId: finding.id,
      file: finding.file,
      line: finding.line,
      originalCode: originalLine.trim(),
      fixedCode: result.fixedCode,
      explanation: result.explanation,
      confidence: result.confidence,
    };
  } catch (error) {
    logger.error(`Failed to generate fix for ${finding.id}: ${error}`);
    return null;
  }
}

/**
 * Generates a unified patch file
 */
function generatePatchFile(fixes: Fix[], repoPath: string): string {
  let patch = `# Security Audit - Automated Fixes
# Generated by SmartAudit Agent
# Review carefully before applying

`;
  
  for (const fix of fixes) {
    patch += `
## Fix for ${fix.findingId}
File: ${fix.file}
Line: ${fix.line}
Confidence: ${fix.confidence}

${fix.explanation}

- ${fix.originalCode}
+ ${fix.fixedCode}

`;
  }
  
  return patch;
}

/**
 * Main fix generation function
 */
export async function generateFixes(
  findings: Finding[],
  repoPath: string
): Promise<GenerateFixesResult> {
  const startTime = Date.now();
  logger.info(`Generating fixes for ${findings.length} findings...`);
  
  try {
    // Filter for auto-fixable issues
    const autoFixable = findings.filter(isAutoFixable);
    logger.info(`${autoFixable.length} findings are auto-fixable`);
    
    // Generate fixes (limit to top 10 for performance)
    const toFix = autoFixable.slice(0, 10);
    const fixPromises = toFix.map(finding => generateFixForFinding(finding, repoPath));
    const fixResults = await Promise.all(fixPromises);
    
    const fixes = fixResults.filter((fix): fix is Fix => fix !== null);
    
    // Generate patch file
    let patchFile: string | undefined;
    if (fixes.length > 0) {
      const patchContent = generatePatchFile(fixes, repoPath);
      patchFile = path.join(repoPath, 'security-fixes.patch');
      await fs.writeFile(patchFile, patchContent, 'utf-8');
      logger.info(`Patch file created: ${patchFile}`);
    }
    
    // Calculate summary
    const summary = {
      total: fixes.length,
      highConfidence: fixes.filter(f => f.confidence === 'high').length,
      mediumConfidence: fixes.filter(f => f.confidence === 'medium').length,
      lowConfidence: fixes.filter(f => f.confidence === 'low').length,
    };
    
    const duration = Date.now() - startTime;
    logger.info(`Fix generation complete in ${duration}ms - ${fixes.length} fixes generated`);
    
    return {
      success: true,
      fixes,
      patchFile,
      summary,
      duration,
    };
  } catch (error) {
    const errorMsg = error instanceof Error ? error.message : String(error);
    logger.error(`Fix generation failed: ${errorMsg}`);
    
    return {
      success: false,
      fixes: [],
      summary: { total: 0, highConfidence: 0, mediumConfidence: 0, lowConfidence: 0 },
      duration: Date.now() - startTime,
      error: errorMsg,
    };
  }
}
